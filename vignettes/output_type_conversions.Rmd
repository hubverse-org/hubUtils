---
title: "Output type conversion"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.width = 9,
  fig.height = 4
)
```

```{r set up, message = FALSE}
library(hubExamples)
library(hubUtils)
library(hubData)

library(dplyr)
library(ggplot2)

devtools::load_all()
theme_set(theme_bw())
options(width = 500)
```

## Overview/Background

We are sometimes interested in converting between output types, for use cases such as:

1. Summarizing distributions described by samples (e.g. obtaining a mean, median, or quantiles)
    - Often applicable to plotting
2. Transforming from non-sample probabilistic output types (quantile, cdf, pmf) to other output types
    - e.g. quantile -> pmf for FluSight 2023-2024
3. Creating ensembles from samples

This functionality is important as the hubverse moves toward greater support of the sample output type, as dealing with samples makes up a significant portion of use cases. 

Implementation will also help us think about how we want to make ensembles of sample type forecasts within `hubEnsembles`, which has been a long-discussed topic with different iterations of ideas.

As of now, we do not provide many tools to deal with the sample output type

### Example 1: Samples -> Other output types

First, we print an example of sample output type forecasts from `hubExamples`:

```{r samples data}
hubExamples::forecast_outputs |>
  filter(output_type == "sample", output_type_id %in% 4301:4305) |>
  select(-"target_end_date") # remove target_end_date column for readability
```

These are trajectory samples, meaning that they are dependent across horizons for the same index. The `hubExamples` vignette plots a subset of the predictions for just Massachusetts with reference date December 17, 2022 generated by the "MOBS-GLEAM_FLUH" model:

```{r samples plot}
ggplot() +
  geom_line(
    data = hubExamples::forecast_target_ts |>
      filter(location == "25",
             date >= "2022-10-01", date <= "2023-04-01"),
    mapping = aes(x = date, y = observation)
  ) +
  geom_line(
    data = forecast_outputs |>
      filter(
        location == "25",
        model_id == "MOBS-GLEAM_FLUH",
        reference_date == "2022-12-17",
        output_type == "sample"
      ),
    mapping = aes(x = target_end_date, y = value, group = output_type_id),
    color = "blue",
    alpha = 0.3
  ) +
  theme_bw()
```

We can get some idea of the underlying distribution by plotting, but we may be interested in summarizing the data points to obtain a mean, median, or quantile levels. Right now, we have a draft function in `hubUtils` that can perform these conversions:

```{r samples conversion}
converted_outputs <- hubExamples::forecast_outputs |>
  filter(output_type == "sample") |>
  convert_output_type(
    new_output_type = c("quantile", "mean", "median"),
    new_output_type_id = list("quantile" = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),
                              "mean" = NA,
                              "median" = NA)
  )

converted_outputs |>
  filter(output_type_id %in% c(0.25, 0.5, 0.75, NA)) |>
  arrange("reference_date", "horizon") |>
  select(-"target_end_date") # remove target_end_date column for readability
```

We can also now plot these converted forecasts using `hubVis::plot_step_ahead_model output()` for the quantile and median output types, which produces a clean and simple plot of the underlying distribution. Below we show such predictions along with the observed hospital admission counts for Massachusetts and Texas:

```{r converted plots}
converted_outputs |>
  filter(output_type == "quantile") |>
  hubVis::plot_step_ahead_model_output(
    target_data = hubExamples::forecast_target_ts |>
      filter(location %in% c("25", "48"),
             date >= "2022-10-01", date <= "2023-04-01"),
    use_median_as_point = TRUE,
    x_col_name = "target_end_date",
    intervals = c(0.5, 0.8, 0.9),
    facet = "location",
    group = "reference_date",
    interactive = FALSE
  )
```

Plotting the quantiles instead of the individual sample trajectories has the advantage of being able to clearly display multiple forecasts on the same plot.

### Example 2: Quantile -> PMF

Let's print an example of quantile output type forecasts from `hubExamples`:

```{r quantiles data}
hubExamples::forecast_outputs |>
  filter(output_type == "quantile", output_type_id %in% c(0.25, 0.5, 0.75)) |>
  select(-"target_end_date") # remove target_end_date column for readability
```

Then plot the predictions, which are the quantile and median output types, along with the observed hospital admission counts for Massachusetts and Texas.

```{r quantiles plot, warning = FALSE}
hubVis::plot_step_ahead_model_output(
  model_output_data = hubExamples::forecast_outputs |>
    filter(output_type %in% c("quantile", "median")),
  target_data = hubExamples::forecast_target_ts |>
    filter(location %in% c("25", "48"),
           date >= "2022-10-01", date <= "2023-04-01"),
  use_median_as_point = TRUE,
  x_col_name = "target_end_date",
  intervals = c(0.5, 0.8, 0.9),
  facet = "location",
  group = "reference_date",
  interactive = FALSE
)
```

But we may be interested in converting these quantile forecasts into the pmf output type, like FluSight 2023-2024 which also used a target that categorized the change in influenza hospital admissions into several bins. A modified example of this can be shown using the `hubExamples` example forecast data and a conversion function `idforecastutils::transform_quantile_to_pmf()`.

Before we perform the transformation, though, we must first define the upper and lower endpoints of the categorical bins. In this example, we illustrate getting bin probabilities with different bin endpoints for each location. We bin hospital admissions into categories of "low", "moderate", "high", and "very high", with the bin endpoints equal to 2.5, 5, and 7.5 hospitalizations per 100,000 population, based on the populations of Massachusetts (FIPS code 25) and Texas (FIPS code 48)
as reported by the US Census for 2022. (Because the used bins are of the half-open form (lower, upper), we use -Inf for the lower bin endpoint of the "low" category to capture the full predicted probability of that bin.)

```{r quantiles conversion}
state_pops <- c("25" = 6981974, "48" = 30029572)
lower_multipliers <- c("low" = -Inf, "moderate" = 2.5, "high" = 5.0, "very high" = 7.5)
upper_multipliers <- c("low" = 2.5, "moderate" = 5.0, "high" = 7.5, "very high" = Inf)
bin_endpoints <- expand.grid(
  location = c("25", "48"),
  output_type_id = c("low", "moderate", "high", "very high"),
  stringsAsFactors = FALSE
) |>
  mutate(
    lower = lower_multipliers[output_type_id] * state_pops[location] / 100000,
    upper = upper_multipliers[output_type_id] * state_pops[location] / 100000
  )
print(bin_endpoints)

pmf_outputs <- hubExamples::forecast_outputs |>
  filter(output_type == "quantile") |>
  idforecastutils::transform_quantile_to_pmf(bin_endpoints = bin_endpoints) |>
  ungroup()

pmf_outputs |>
  select(-"target_end_date") # remove target_end_date column for readability
```

We can then also plot these pmf forecasts with a plot that shows the predictive distributions for these targets from the three included models. Color indicates the predicted probability for each intensity category. The observed category is indicated with a `+` in the plot, while unobserved categories are indicated with an `o`. Here, the PMF value recorded in `forecast_target_observations` corresponds to a point mass at the observed category, with a value of 1 for the observed category and a value of 0 for the other categories.

```{r pmf plots, message = FALSE}
# extract a subset of forecasts to plot and
# set the output_type_id to be an ordered factor
pmf_cat_names <- c("low", "moderate", "high", "very high")
forecasts_to_plot <- pmf_outputs |>
  filter(reference_date == "2022-12-17") |>
  mutate(output_type_id = factor(output_type_id, levels = pmf_cat_names, ordered = TRUE))

# extract the corresponding observations
observations_to_plot <- hubExamples::forecast_target_observations |>
  filter(
    location %in% c("25", "48"),
    target == "wk flu hosp rate category",
    target_end_date %in% forecasts_to_plot$target_end_date
  ) |>
  mutate(output_type_id = factor(output_type_id, levels = pmf_cat_names, ordered = TRUE))

# plot the predictions and observations
ggplot() +
  geom_raster(
    mapping = aes(x = target_end_date, y = output_type_id, fill = value),
    data = forecasts_to_plot
  ) +
  scale_fill_viridis_c(
    breaks = seq(from = 0, to = 1, by = 0.2),
    limits = c(0, 1)
  ) +
  geom_point(
    mapping = aes(x = target_end_date, y = output_type_id,
                  shape = factor(observation)),
    color = "#888888",
    size = 3, stroke = 2,
    data = observations_to_plot,
  ) +
  scale_shape_manual(
    values = c(1, 3),
    breaks = c(0, 1)
  ) +
  facet_grid(rows = vars(model_id), cols = vars(location)) +
  ylab("output_type_id (intensity level category)")
```


## The details

### API/Standardization

Currently, we have two different functions that perform output type transformations:

  - `hubUtils::convert_output_types(model_out_tbl, new_output_type, new_output_type_id, n_samples, ...)`
  - `idforecastutils::transform_quantile_to_pmf(model_out_tbl, bin_endpoints, tail_dist)`

We would like to unify these two functions, and previous discussion had suggested we create a single user-facing function to handle all data type conversions, which would do so by calling the appropriate internal functions.

Here, we propose simply expanding `convert_output_types()` to handle the quantile to PMF case, as the `bin_endpoints` argument can be thought of as specifying the `new_output_type_id`. An example call might look like:

```{r, eval = FALSE}
hubUtils::convert_output_types(model_out_tbl,
                               new_output_type = "pmf", 
                               new_output_type_id = bin_endpoints,
                               n_samples = NULL, ...)
```

Note the `n_samples` argument will specify the number of samples to generate per unique modeling task if the underlying calculation being performed requires samples. (Currently most conversions do, but we plan to change the internal mechanisms going forward. See Underlying transformation calculations for more information.)

### Supported transformations

Summary of currently supported transformations (quantile -> pmf currently performed by `transform_quantile_to_pmf()`):

Initial output type | Terminal output type
:-------------------|:--------------------
sample | mean, median, quantile, cdf
quantile | mean, median, cdf, *pmf*
cdf | mean, median, quantile

Ideally, we would like to add support in the future for:

1. Samples as a terminal output type
2. PMF as an initial output type
3. PMF as a terminal output type for CDF (and maybe sample)
4. (Interpolation/extrapolation for quantile to quantile and cdf to cdf transformations)
5. [Allow for the initial model outputs to contain multiple output types, with the ability to specify transformations to be performed]

### Underlying transformation calculations

Currently, `convert_output_type()` performs the transformation calculations by reconstructing a full probabilistic distribution from the starting forecasts using pseudo-random samples, generated from `distfromq`, then obtained the new output types from those samples. (The one exception for the quantile -> median conversion.)

However, this method is somewhat inefficient and leads to unnecessary sampling error for certain transformations. Instead, we will split the type of intermediary step based on the terminal output type:

Terminal output type | Underlying calculation
:-------------------|:--------------------
sample | pseudo-random samples
mean | pseudo-random samples
median | estimated quantile function
quantile | estimated quantile function
cdf | estimated cumulative distribution function
pmf | estimated cumulative distribution function

### PMF bin handling

Recall that for a terminal output type of PMF, we needed to specify the upper and lower bin endpoints of the categories (see Example 2). 

Likewise for a PMF initial output type, we will also need a way for the user to provide bin endpoints. However, we currently do not have a parameter that can be fed such an argument and thus need to create one.

Consider adding an argument to the output type conversion function `initial_output_type_id` or `initial_bin_endpoints` that can store this information when needed and be set to NULL (as a default) otherwise.

### Output type IDs dependent on task IDs

There are cases in which output type IDs may be dependent on task IDs, like the FluSight 2023-2024 PMF target (see Example 2 for simplified version). Here, the bin category definitions were dependent on horizon and location. As this feature was requested by CDC FluSight and we at UMass need it for our flu models, we will plan on implementing it for all supported (probabilistic) terminal output type transformations.
